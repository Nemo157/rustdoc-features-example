var searchIndex = {};
searchIndex["diesel"] = {"doc":"Diesel is an ORM and query builder designed to reduce the boilerplate for database\ninteractions. [A getting started guide](http://diesel.rs/guides/getting-started/) can be\nfound on our website.","items":[[5,"insert","diesel","Creates an insert statement. Will add the given data to a table. This\nfunction is not exported by default. As with other commands, the resulting\nquery can return the inserted rows if you choose.",null,{"inputs":[{"name":"t"}],"output":{"name":"incompleteinsertstatement"}}],[5,"update","","Creates an update statement. Helpers for updating a single row can be\ngenerated by deriving [`AsChangeset`][trait.AsChangeset.html]",null,{"inputs":[{"name":"t"}],"output":{"name":"incompleteupdatestatement"}}],[5,"delete","","Creates a delete statement. Will delete the records in the given set.\nBecause this function has a very generic name, it is not exported by\ndefault.",null,{"inputs":[{"name":"t"}],"output":{"name":"deletestatement"}}],[5,"select","","Creates a bare select statement, with no from clause. Primarily used for\ntesting diesel itself, but likely useful for third party crates as well. The\ngiven expressions must be selectable from anywhere.",null,{"inputs":[{"name":"t"}],"output":{"name":"selectstatement"}}],[0,"associations","","Traits related to relationships between multiple tables.",null,null],[8,"BelongsTo","diesel::associations","",null,null],[16,"ForeignKeyColumn","","",0,null],[10,"foreign_key","","",0,null],[10,"foreign_key_column","","",0,{"inputs":[],"output":{"name":"foreignkeycolumn"}}],[8,"GroupedBy","","",null,null],[10,"grouped_by","","",1,null],[8,"Identifiable","","Represents a struct which can be identified on a single table in the\ndatabase. This must be implemented to use associations, and some features of\nupdating.",null,null],[16,"Id","","",2,null],[16,"Table","","",2,null],[10,"table","","",2,{"inputs":[],"output":{"name":"table"}}],[10,"id","","",2,null],[0,"backend","diesel","",null,null],[3,"Debug","diesel::backend","",null,null],[8,"Backend","","",null,null],[16,"QueryBuilder","","",3,null],[16,"BindCollector","","",3,null],[16,"RawValue","","",3,null],[8,"TypeMetadata","","",null,null],[16,"TypeMetadata","","",4,null],[8,"SupportsReturningClause","","",null,null],[8,"SupportsDefaultKeyword","","",null,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[0,"connection","diesel","",null,null],[8,"SimpleConnection","diesel::connection","",null,null],[8,"Connection","","",null,null],[16,"Backend","","",6,null],[10,"establish","","Establishes a new connection to the database at the given URL. The URL\nshould be a valid connection string for a given backend. See the\ndocumentation for the specific backend for specifics.",6,{"inputs":[{"name":"str"}],"output":{"name":"connectionresult"}}],[11,"transaction","","Executes the given function inside of a database transaction. When\na transaction is already occurring, savepoints will be used to emulate a nested\ntransaction.",6,null],[11,"begin_test_transaction","","Creates a transaction that will never be committed. This is useful for\ntests. Panics if called while inside of a transaction.",6,null],[11,"test_transaction","","Executes the given function inside a transaction, but does not commit\nit. Panics if the given function returns an `Err`.",6,null],[0,"expression","diesel","AST types representing various typed SQL expressions. Almost all types\nimplement either [`Expression`](trait.Expression.html) or\n[`AsExpression`](trait.AsExpression.html).",null,null],[0,"expression_methods","diesel::expression","Adds various methods to construct new expressions. These traits are exported\nby default, and implemented automatically.",null,null],[0,"bool_expression_methods","diesel::expression::expression_methods","",null,null],[8,"BoolExpressionMethods","diesel::expression::expression_methods::bool_expression_methods","",null,null],[11,"and","","Creates a SQL `AND` expression",7,null],[11,"or","","Creates a SQL `OR` expression",7,null],[0,"escape_expression_methods","diesel::expression::expression_methods","",null,null],[8,"EscapeExpressionMethods","diesel::expression::expression_methods::escape_expression_methods","Adds the `escape` method to `LIKE` and `NOT LIKE`. This is used to specify\nthe escape character for the pattern.",null,null],[11,"escape","","",8,null],[0,"global_expression_methods","diesel::expression::expression_methods","",null,null],[8,"ExpressionMethods","diesel::expression::expression_methods::global_expression_methods","",null,null],[11,"aliased","","Alias an expression for use alongside\n[`with`](../../../trait.WithDsl.html).",9,null],[11,"eq","","Creates a SQL `=` expression.",9,null],[11,"ne","","Creates a SQL `!=` expression.",9,null],[11,"eq_any","","Creates a SQL `IN` statement. Queries using this method will not be\nplaced in the prepared statement cache. On PostgreSQL, you should use\n`eq(any())` instead. This method may change in the future to\nautomatically perform `= ANY` on PostgreSQL.",9,null],[11,"is_null","","Creates a SQL `IS NULL` expression.",9,null],[11,"is_not_null","","Creates a SQL `IS NOT NULL` expression.",9,null],[11,"gt","","Creates a SQL `&gt;` expression.",9,null],[11,"ge","","Creates a SQL `&gt;=` expression.",9,null],[11,"lt","","Creates a SQL `&lt;` expression.",9,null],[11,"le","","Creates a SQL `&lt;=` expression.",9,null],[11,"between","","Creates a SQL `BETWEEN` expression using the given range.",9,null],[11,"not_between","","Creates a SQL `NOT BETWEEN` expression using the given range.",9,null],[11,"desc","","Creates a SQL `DESC` expression, representing this expression in\ndescending order.",9,null],[11,"asc","","Creates a SQL `ASC` expression, representing this expression in\nascending order.",9,null],[11,"nullable","","Converts this potentially non-null expression into one which is treated\nas nullable. This method has no impact on the generated SQL, and is only\nused to allow certain comparisons that would otherwise fail to compile.",9,null],[0,"text_expression_methods","diesel::expression::expression_methods","",null,null],[8,"TextExpressionMethods","diesel::expression::expression_methods::text_expression_methods","",null,null],[11,"like","","Returns a SQL `LIKE` expression",10,null],[11,"not_like","","Returns a SQL `NOT LIKE` expression",10,null],[0,"helper_types","diesel::expression","The types in this module are all shorthand for `PredicateType&lt;Lhs,\nAsExpr&lt;Rhs, Lhs&gt;&gt;`. Since we often need to return concrete types, instead of\na boxed trait object, these can be useful for writing concise return types.",null,null],[3,"IsNull","diesel::expression::helper_types","",null,null],[3,"IsNotNull","","",null,null],[3,"Asc","","",null,null],[3,"Desc","","",null,null],[6,"SqlTypeOf","","",null,null],[6,"AsExpr","","",null,null],[6,"AsExprOf","","",null,null],[6,"Eq","","",null,null],[6,"NotEq","","",null,null],[6,"Gt","","",null,null],[6,"GtEq","","",null,null],[6,"Lt","","",null,null],[6,"LtEq","","",null,null],[6,"And","","",null,null],[6,"Like","","",null,null],[6,"NotLike","","",null,null],[6,"Between","","",null,null],[6,"NotBetween","","",null,null],[6,"EqAny","","",null,null],[11,"fmt","","",11,null],[11,"clone","","",11,null],[11,"new","","",11,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"has_static_query_id","","",11,{"inputs":[],"output":{"name":"bool"}}],[11,"to_sql","","",11,null],[11,"collect_binds","","",11,null],[11,"is_safe_to_cache_prepared","","",11,null],[11,"fmt","","",12,null],[11,"clone","","",12,null],[11,"new","","",12,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"has_static_query_id","","",12,{"inputs":[],"output":{"name":"bool"}}],[11,"to_sql","","",12,null],[11,"collect_binds","","",12,null],[11,"is_safe_to_cache_prepared","","",12,null],[11,"fmt","","",13,null],[11,"clone","","",13,null],[11,"new","","",13,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"has_static_query_id","","",13,{"inputs":[],"output":{"name":"bool"}}],[11,"to_sql","","",13,null],[11,"collect_binds","","",13,null],[11,"is_safe_to_cache_prepared","","",13,null],[11,"fmt","","",14,null],[11,"clone","","",14,null],[11,"new","","",14,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"has_static_query_id","","",14,{"inputs":[],"output":{"name":"bool"}}],[11,"to_sql","","",14,null],[11,"collect_binds","","",14,null],[11,"is_safe_to_cache_prepared","","",14,null],[0,"sql_literal","diesel::expression","",null,null],[3,"SqlLiteral","diesel::expression::sql_literal","Available for when you truly cannot represent something using the expression\nDSL. You will need to provide the type of the expression, in addition to the\nSQL. The compiler will be unable to verify the correctness of this type.",null,null],[5,"sql","","",null,{"inputs":[{"name":"str"}],"output":{"name":"sqlliteral"}}],[11,"fmt","","",15,null],[11,"clone","","",15,null],[11,"new","","",15,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"to_sql","","",15,null],[11,"collect_binds","","",15,null],[11,"is_safe_to_cache_prepared","","",15,null],[11,"has_static_query_id","","",15,{"inputs":[],"output":{"name":"bool"}}],[0,"dsl","diesel::expression","Reexports various top level functions and core extensions that are too\ngeneric to export by default. This module exists to conveniently glob import\nin functions where you need them.",null,null],[3,"now","diesel::expression::dsl","Represents the SQL CURRENT_TIMESTAMP constant. This is equivalent to the\n`NOW()` function on backends that support it.",null,null],[3,"Max","","",null,null],[3,"Min","","",null,null],[3,"Sum","","",null,null],[3,"Avg","","",null,null],[5,"count","","Creates a SQL `COUNT` expression",null,{"inputs":[{"name":"t"}],"output":{"name":"count"}}],[5,"count_star","","Creates a SQL `COUNT(*)` expression",null,{"inputs":[],"output":{"name":"countstar"}}],[5,"date","","Represents the SQL DATE() function. The argument should be a Timestamp\nexpression, and the return value will be an expression of type Date",null,{"inputs":[{"name":"x"}],"output":{"name":"date"}}],[5,"max","","Represents a SQL `MAX` function. This function can only take types which are\nordered.",null,{"inputs":[{"name":"t"}],"output":{"name":"max"}}],[5,"min","","Represents a SQL `MIN` function. This function can only take types which are\nordered.",null,{"inputs":[{"name":"t"}],"output":{"name":"min"}}],[5,"sum","","Represents a SQL `SUM` function. This function can only take types which are\nFoldable.",null,{"inputs":[{"name":"t"}],"output":{"name":"sum"}}],[5,"avg","","Represents a SQL `AVG` function. This function can only take types which are\nFoldable.",null,{"inputs":[{"name":"t"}],"output":{"name":"avg"}}],[5,"sql","","",null,{"inputs":[{"name":"str"}],"output":{"name":"sqlliteral"}}],[6,"date","","",null,null],[8,"Expression","diesel::expression","Represents a typed fragment of SQL. Apps should not need to implement this\ntype directly, but it may be common to use this as type boundaries.\nLibraries should consider using\n[`infix_predicate!`](../macro.infix_predicate!.html) or\n[`postfix_predicate!`](../macro.postfix_predicate!.html) instead of\nimplementing this directly.",null,null],[16,"SqlType","","",16,null],[8,"AsExpression","","Describes how a type can be represented as an expression for a given type.\nThese types couldn&#39;t just implement [`Expression`](trait.Expression.html)\ndirectly, as many things can be used as an expression of multiple types.\n(`String` for example, can be used as either\n[`VarChar`](../types/struct.VarChar.html) or\n[`Text`](../types/struct.Text.html)).",null,null],[16,"Expression","","",17,null],[10,"as_expression","","",17,null],[8,"SelectableExpression","","Indicates that an expression can be selected from a source. The second type\nargument is optional, but is used to indicate that the right side of a left\nouter join is nullable, even if it wasn&#39;t before.",null,null],[8,"NonAggregate","","Marker trait to indicate that an expression does not include any aggregate\nfunctions. Used to ensure that aggregate expressions aren&#39;t mixed with\nnon-aggregate expressions in a select clause, and that they&#39;re never\nincluded in a where clause.",null,null],[8,"BoxableExpression","","Helper trait used when boxing expressions. This exists to work around the\nfact that Rust will not let us use non-core types as bounds on a trait\nobject (you could not return `Box&lt;Expression+NonAggregate&gt;`)",null,null],[11,"has_static_query_id","","",18,{"inputs":[],"output":{"name":"bool"}}],[0,"query_builder","diesel","Contains traits responsible for the actual construction of SQL statements",null,null],[3,"IncompleteUpdateStatement","diesel::query_builder","The type returned by [`update`](fn.update.html). The only thing you can do\nwith this type is call `set` on it.",null,null],[3,"UpdateStatement","","",null,null],[3,"IncompleteInsertStatement","","The structure returned by [`insert`](fn.insert.html). The only thing that can be done with it\nis call `into`.",null,null],[0,"debug","","",null,null],[0,"bind_collector","","",null,null],[3,"RawBytesBindCollector","diesel::query_builder::bind_collector","",null,null],[12,"binds","","",19,null],[8,"BindCollector","","",null,null],[10,"push_bound_value","","",20,null],[11,"fmt","","",19,null],[11,"new","","",19,{"inputs":[],"output":{"name":"self"}}],[11,"push_bound_value","","",19,null],[0,"where_clause","diesel::query_builder","",null,null],[3,"NoWhereClause","diesel::query_builder::where_clause","",null,null],[3,"WhereClause","","",null,null],[8,"WhereAnd","","",null,null],[16,"Output","","",21,null],[10,"and","","",21,null],[11,"fmt","","",22,null],[11,"clone","","",22,null],[11,"has_static_query_id","","",22,{"inputs":[],"output":{"name":"bool"}}],[11,"to_sql","","",22,null],[11,"collect_binds","","",22,null],[11,"is_safe_to_cache_prepared","","",22,null],[11,"and","","",22,null],[11,"into","","",22,null],[11,"fmt","","",23,null],[11,"clone","","",23,null],[11,"to_sql","","",23,null],[11,"collect_binds","","",23,null],[11,"is_safe_to_cache_prepared","","",23,null],[11,"has_static_query_id","","",23,{"inputs":[],"output":{"name":"bool"}}],[11,"and","","",23,null],[11,"into","","",23,null],[0,"insert_statement","diesel::query_builder","",null,null],[3,"IncompleteInsertStatement","diesel::query_builder::insert_statement","The structure returned by [`insert`](fn.insert.html). The only thing that can be done with it\nis call `into`.",null,null],[3,"InsertStatement","","",null,null],[3,"Insert","","",null,null],[11,"fmt","","",24,null],[11,"clone","","",24,null],[11,"into","","Specify which table the data passed to `insert` should be added to.",24,null],[11,"fmt","","",25,null],[11,"clone","","",25,null],[11,"to_sql","","",25,null],[11,"collect_binds","","",25,null],[11,"is_safe_to_cache_prepared","","",25,null],[11,"has_static_query_id","","",25,{"inputs":[],"output":{"name":"bool"}}],[11,"as_query","","",25,null],[11,"returning","","Specify what expression is returned after execution of the `insert`.\n# Examples",25,null],[11,"fmt","","",26,null],[11,"clone","","",26,null],[11,"to_sql","","",26,null],[11,"collect_binds","","",26,null],[11,"is_safe_to_cache_prepared","","",26,null],[11,"has_static_query_id","","",26,{"inputs":[],"output":{"name":"bool"}}],[0,"update_statement","diesel::query_builder","",null,null],[3,"IncompleteUpdateStatement","diesel::query_builder::update_statement","The type returned by [`update`](fn.update.html). The only thing you can do\nwith this type is call `set` on it.",null,null],[3,"UpdateStatement","","",null,null],[0,"changeset","","",null,null],[8,"AsChangeset","diesel::query_builder::update_statement::changeset","Types which can be passed to\n[`update.set`](struct.IncompleteUpdateStatement.html#method.set).",null,null],[16,"Target","","",27,null],[16,"Changeset","","",27,null],[10,"as_changeset","","",27,null],[8,"Changeset","","Apps should not need to concern themselves with this trait.",null,null],[10,"is_noop","","",28,null],[10,"to_sql","","",28,null],[10,"collect_binds","","",28,null],[0,"target","diesel::query_builder::update_statement","",null,null],[8,"IntoUpdateTarget","diesel::query_builder::update_statement::target","",null,null],[16,"Table","","",29,null],[16,"WhereClause","","",29,null],[10,"into_update_target","","",29,null],[11,"fmt","diesel::query_builder::update_statement","",30,null],[11,"set","","",30,null],[11,"fmt","","",31,null],[11,"clone","","",31,null],[11,"to_sql","","",31,null],[11,"collect_binds","","",31,null],[11,"is_safe_to_cache_prepared","","",31,null],[11,"has_static_query_id","","",31,{"inputs":[],"output":{"name":"bool"}}],[11,"as_query","","",31,null],[11,"returning","","Specify what expression is returned after execution of the `update`.\n# Examples",31,null],[6,"BuildQueryResult","diesel::query_builder","",null,null],[8,"QueryId","","",null,null],[16,"QueryId","","",32,null],[10,"has_static_query_id","","",32,{"inputs":[],"output":{"name":"bool"}}],[11,"query_id","","",32,{"inputs":[],"output":{"name":"option"}}],[8,"AsChangeset","","Types which can be passed to\n[`update.set`](struct.IncompleteUpdateStatement.html#method.set).",null,null],[16,"Target","","",27,null],[16,"Changeset","","",27,null],[10,"as_changeset","","",27,null],[8,"Changeset","","Apps should not need to concern themselves with this trait.",null,null],[10,"is_noop","","",28,null],[10,"to_sql","","",28,null],[10,"collect_binds","","",28,null],[8,"IntoUpdateTarget","","",null,null],[16,"Table","","",29,null],[16,"WhereClause","","",29,null],[10,"into_update_target","","",29,null],[8,"QueryBuilder","","Apps should not need to concern themselves with this trait.",null,null],[10,"push_sql","","",33,null],[10,"push_identifier","","",33,null],[10,"push_bind_param","","",33,null],[8,"Query","","A complete SQL query with a return type. This can be a select statement, or\na command such as `update` or `insert` with a `RETURNING` clause. Unlike\n[`Expression`](../expression/trait.Expression.html), types implementing this\ntrait are guaranteed to be executable on their own.",null,null],[16,"SqlType","","",34,null],[8,"QueryFragment","","An untyped fragment of SQL. This may be a complete SQL command (such as\nan update statement without a `RETURNING` clause), or a subsection (such as\nour internal types used to represent a `WHERE` clause). All methods on\n[`Connection`](../struct.Connection.html) that execute a query require this\ntrait to be implemented.",null,null],[10,"to_sql","","",35,null],[10,"collect_binds","","",35,null],[10,"is_safe_to_cache_prepared","","",35,null],[8,"AsQuery","","Types that can be converted into a complete, typed SQL query. This is used\ninternally to automatically add the right select clause when none is\nspecified, or to automatically add `RETURNING *` in certain contexts",null,null],[16,"SqlType","","",36,null],[16,"Query","","",36,null],[10,"as_query","","",36,null],[0,"types","diesel","Types which represent a native SQL data type, and the conversions between\nthem and Rust primitives. The structs in this module are *only* used as\nmarkers to represent a SQL type, and shouldn&#39;t be used in your structs. See\nthe documentation for each type to see the Rust types that can be used with\na corresponding SQL type. Additional types can be added by other crates.",null,null],[3,"Bool","diesel::types","The boolean SQL type. On SQLite this is emulated with an integer.",null,null],[3,"SmallInt","","The small integer SQL type.",null,null],[3,"Integer","","The integer SQL type.",null,null],[3,"BigInt","","The big integer SQL type.",null,null],[3,"Float","","The float SQL type.",null,null],[3,"Double","","The double precision float SQL type.",null,null],[3,"Numeric","","The numeric SQL type.",null,null],[3,"Text","","The text SQL type.",null,null],[3,"Binary","","The binary SQL type.",null,null],[3,"Date","","The date SQL type.",null,null],[3,"Interval","","The interval SQL type.",null,null],[3,"Time","","The time SQL type.",null,null],[3,"Timestamp","","The timestamp/datetime SQL type.",null,null],[3,"Nullable","","The nullable SQL type. This wraps another SQL type to indicate that it can\nbe null. By default all values are assumed to be `NOT NULL`.",null,null],[4,"IsNull","","Tiny enum to make the return type of `ToSql` more descriptive",null,null],[13,"Yes","","",37,null],[13,"No","","",37,null],[0,"ops","","Apps should not need to concern themselves with this module.",null,null],[8,"Add","diesel::types::ops","",null,null],[16,"Rhs","","",38,null],[16,"Output","","",38,null],[8,"Sub","","",null,null],[16,"Rhs","","",39,null],[16,"Output","","",39,null],[8,"Mul","","",null,null],[16,"Rhs","","",40,null],[16,"Output","","",40,null],[8,"Div","","",null,null],[16,"Rhs","","",41,null],[16,"Output","","",41,null],[11,"has_static_query_id","diesel::types","",42,{"inputs":[],"output":{"name":"bool"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"has_static_query_id","diesel::types","",43,{"inputs":[],"output":{"name":"bool"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"has_static_query_id","diesel::types","",44,{"inputs":[],"output":{"name":"bool"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"has_static_query_id","diesel::types","",45,{"inputs":[],"output":{"name":"bool"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"has_static_query_id","diesel::types","",46,{"inputs":[],"output":{"name":"bool"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"has_static_query_id","diesel::types","",47,{"inputs":[],"output":{"name":"bool"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"has_static_query_id","diesel::types","",48,{"inputs":[],"output":{"name":"bool"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"has_static_query_id","diesel::types","",49,{"inputs":[],"output":{"name":"bool"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"has_static_query_id","diesel::types","",50,{"inputs":[],"output":{"name":"bool"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"has_static_query_id","diesel::types","",51,{"inputs":[],"output":{"name":"bool"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"has_static_query_id","diesel::types","",52,{"inputs":[],"output":{"name":"bool"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"has_static_query_id","diesel::types","",53,{"inputs":[],"output":{"name":"bool"}}],[6,"VarChar","","",null,null],[8,"SqlOrd","","",null,null],[8,"Foldable","","",null,null],[16,"Sum","","",54,null],[16,"Avg","","",54,null],[8,"HasSqlType","","",null,null],[10,"metadata","","",55,{"inputs":[],"output":{"name":"typemetadata"}}],[8,"NotNull","","",null,null],[8,"IntoNullable","","",null,null],[16,"Nullable","","",56,null],[8,"FromSql","","How to deserialize a single field of a given type. The input will always be\nthe binary representation, not the text.",null,null],[10,"from_sql","","",57,{"inputs":[{"name":"option"}],"output":{"name":"result"}}],[8,"FromSqlRow","","How to deserialize multiple fields, with a known type. This type is\nimplemented for tuples of various sizes.",null,null],[10,"build_from_row","","",58,{"inputs":[{"name":"t"}],"output":{"name":"result"}}],[8,"ToSql","","Serializes a single value to be sent to the database. The output will be\nincluded as a bind parameter, and is expected to be the binary format, not\ntext.",null,null],[10,"to_sql","","",59,null],[11,"fmt","","",43,null],[11,"clone","","",43,null],[11,"default","","",43,{"inputs":[],"output":{"name":"bool"}}],[11,"fmt","","",44,null],[11,"clone","","",44,null],[11,"default","","",44,{"inputs":[],"output":{"name":"smallint"}}],[11,"fmt","","",45,null],[11,"clone","","",45,null],[11,"default","","",45,{"inputs":[],"output":{"name":"integer"}}],[11,"fmt","","",46,null],[11,"clone","","",46,null],[11,"default","","",46,{"inputs":[],"output":{"name":"bigint"}}],[11,"fmt","","",47,null],[11,"clone","","",47,null],[11,"default","","",47,{"inputs":[],"output":{"name":"float"}}],[11,"fmt","","",48,null],[11,"clone","","",48,null],[11,"default","","",48,{"inputs":[],"output":{"name":"double"}}],[11,"fmt","","",60,null],[11,"clone","","",60,null],[11,"default","","",60,{"inputs":[],"output":{"name":"numeric"}}],[11,"fmt","","",49,null],[11,"clone","","",49,null],[11,"default","","",49,{"inputs":[],"output":{"name":"text"}}],[11,"fmt","","",50,null],[11,"clone","","",50,null],[11,"default","","",50,{"inputs":[],"output":{"name":"binary"}}],[11,"fmt","","",51,null],[11,"clone","","",51,null],[11,"default","","",51,{"inputs":[],"output":{"name":"date"}}],[11,"fmt","","",61,null],[11,"clone","","",61,null],[11,"default","","",61,{"inputs":[],"output":{"name":"interval"}}],[11,"fmt","","",52,null],[11,"clone","","",52,null],[11,"default","","",52,{"inputs":[],"output":{"name":"time"}}],[11,"fmt","","",53,null],[11,"clone","","",53,null],[11,"default","","",53,{"inputs":[],"output":{"name":"timestamp"}}],[11,"fmt","","",42,null],[11,"clone","","",42,null],[11,"default","","",42,{"inputs":[],"output":{"name":"nullable"}}],[11,"fmt","","",37,null],[11,"clone","","",37,null],[11,"eq","","",37,null],[0,"pg","diesel","",null,null],[3,"Pg","diesel::pg","",null,null],[3,"PgTypeMetadata","","",null,null],[12,"oid","","",62,null],[12,"array_oid","","",62,null],[3,"PgConnection","","The connection string expected by `PgConnection::establish`\nshould be a PostgreSQL connection string, as documented at\nhttp://www.postgresql.org/docs/9.4/static/libpq-connect.html#LIBPQ-CONNSTRING",null,null],[3,"PgQueryBuilder","","",null,null],[12,"sql","","",63,null],[0,"expression","","",null,null],[0,"expression_methods","diesel::pg::expression","",null,null],[8,"PgExpressionMethods","diesel::pg::expression::expression_methods","",null,null],[11,"is_not_distinct_from","","Creates a PostgreSQL `IS NOT DISTINCT FROM` expression. This behaves\nidentically to the `=` operator, except that `NULL` is treated as a\nnormal value.",64,null],[8,"ArrayExpressionMethods","","",null,null],[11,"overlaps_with","","Compares two arrays for common elements, using the `&amp;&amp;` operator in\nthe final SQL",65,null],[11,"contains","","Compares whether an array contains another array, using the `@&gt;` operator.",65,null],[11,"is_contained_by","","Compares whether an array is contained by another array, using the `&lt;@` operator.\nThis is the opposite of `contains`",65,null],[8,"SortExpressionMethods","","",null,null],[11,"nulls_first","","Specify that nulls should come before other values in this ordering.\nNormally, nulls come last when sorting in ascending order and first\nwhen sorting in descending order.",66,null],[11,"nulls_last","","Specify that nulls should come after other values in this ordering.\nNormally, nulls come last when sorting in ascending order and first\nwhen sorting in descending order.",66,null],[0,"extensions","diesel::pg::expression","This module contains extensions that are added to core types to aid in\nbuilding expressions. These traits are not exported by default. The are also\nre-exported in `diesel::expression::dsl`",null,null],[8,"MicroIntervalDsl","diesel::pg::expression::extensions","A DSL added to `i64` and `f64` to construct PostgreSQL intervals of less\nthan 1 day.",null,null],[10,"microseconds","","Returns a PgInterval representing `self` as microseconds",67,null],[11,"milliseconds","","Returns a PgInterval representing `self` as milliseconds",67,null],[11,"seconds","","Returns a PgInterval representing `self` as seconds",67,null],[11,"minutes","","Returns a PgInterval representing `self` as minutes",67,null],[11,"hours","","Returns a PgInterval representing `self` as hours",67,null],[11,"microsecond","","Identical to `microseconds`",67,null],[11,"millisecond","","Identical to `milliseconds`",67,null],[11,"second","","Identical to `seconds`",67,null],[11,"minute","","Identical to `minutes`",67,null],[11,"hour","","Identical to `hours`",67,null],[8,"DayAndMonthIntervalDsl","","A DSL added to `i32` and `f64` to construct PostgreSQL intervals of greater\nthan 1 day.",null,null],[10,"days","","Returns a PgInterval representing `self` in days",68,null],[10,"months","","Returns a PgInterval representing `self` in monhts",68,null],[11,"weeks","","Returns a PgInterval representing `self` in weeks",68,null],[11,"years","","Returns a PgInterval representing `self` in weeks",68,null],[11,"day","","Identical to `days`",68,null],[11,"week","","Identical to `weeks`",68,null],[11,"month","","Identical to `months`",68,null],[11,"year","","Identical to `years`",68,null],[0,"dsl","diesel::pg::expression","PostgreSQL specific expression DSL methods. This module will be glob\nimported by [`expression::dsl`](../../expression/dsl/index.html) when\ncompiled with the `feature = &quot;postgres&quot;` flag.",null,null],[5,"any","diesel::pg::expression::dsl","Creates a PostgreSQL `ANY` expression.",null,{"inputs":[{"name":"t"}],"output":{"name":"any"}}],[5,"all","","Creates a PostgreSQL `ALL` expression.",null,{"inputs":[{"name":"t"}],"output":{"name":"all"}}],[11,"fmt","diesel::pg","",69,null],[11,"clone","","",69,null],[11,"fmt","","",62,null],[11,"clone","","",62,null],[11,"new","","",63,{"inputs":[{"name":"rc"}],"output":{"name":"self"}}],[11,"push_sql","","",63,null],[11,"push_identifier","","",63,null],[11,"push_bind_param","","",63,null],[11,"batch_execute","","",70,null],[11,"establish","","",70,{"inputs":[{"name":"str"}],"output":{"name":"connectionresult"}}],[0,"types","","",null,null],[11,"metadata","","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[0,"date_and_time","diesel::pg::types","",null,null],[3,"PgTimestamp","diesel::pg::types::date_and_time","Timestamps are represented in Postgres as a 64 bit signed integer representing the number of\nmicroseconds since January 1st 2000. This struct is a dumb wrapper type, meant only to indicate\nthe integer&#39;s meaning.",null,null],[12,"0","","",71,null],[3,"PgDate","","Dates are represented in Postgres as a 32 bit signed integer representing the number of julian\ndays since January 1st 2000. This struct is a dumb wrapper type, meant only to indicate the\ninteger&#39;s meaning.",null,null],[12,"0","","",72,null],[3,"PgTime","","Time is represented in Postgres as a 64 bit signed integer representing the number of\nmicroseconds since midnight. This struct is a dumb wrapper type, meant only to indicate the\ninteger&#39;s meaning.",null,null],[12,"0","","",73,null],[3,"PgInterval","","Intervals in Postgres are separated into 3 parts. A 64 bit integer representing time in\nmicroseconds, a 32 bit integer representing number of minutes, and a 32 bit integer\nrepresenting number of months. This struct is a dumb wrapper type, meant only to indicate the\nmeaning of these parts.",null,null],[12,"microseconds","","",74,null],[12,"days","","",74,null],[12,"months","","",74,null],[11,"arbitrary","","",72,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"arbitrary","","",73,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"arbitrary","","",71,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"arbitrary","","",74,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"fmt","diesel::pg::types::date_and_time","",71,null],[11,"clone","","",71,null],[11,"eq","","",71,null],[11,"ne","","",71,null],[11,"partial_cmp","","",71,null],[11,"lt","","",71,null],[11,"le","","",71,null],[11,"gt","","",71,null],[11,"ge","","",71,null],[11,"cmp","","",71,null],[11,"fmt","","",72,null],[11,"clone","","",72,null],[11,"eq","","",72,null],[11,"ne","","",72,null],[11,"partial_cmp","","",72,null],[11,"lt","","",72,null],[11,"le","","",72,null],[11,"gt","","",72,null],[11,"ge","","",72,null],[11,"cmp","","",72,null],[11,"fmt","","",73,null],[11,"clone","","",73,null],[11,"eq","","",73,null],[11,"ne","","",73,null],[11,"partial_cmp","","",73,null],[11,"lt","","",73,null],[11,"le","","",73,null],[11,"gt","","",73,null],[11,"ge","","",73,null],[11,"cmp","","",73,null],[11,"fmt","","",74,null],[11,"clone","","",74,null],[11,"eq","","",74,null],[11,"ne","","",74,null],[11,"new","","",74,{"inputs":[{"name":"i64"},{"name":"i32"},{"name":"i32"}],"output":{"name":"self"}}],[11,"from_microseconds","","",74,{"inputs":[{"name":"i64"}],"output":{"name":"self"}}],[11,"from_days","","",74,{"inputs":[{"name":"i32"}],"output":{"name":"self"}}],[11,"from_months","","",74,{"inputs":[{"name":"i32"}],"output":{"name":"self"}}],[11,"build_from_row","","",72,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[11,"build","","",72,{"inputs":[{"name":"row"}],"output":{"name":"self"}}],[11,"build_from_row","","",73,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[11,"build","","",73,{"inputs":[{"name":"row"}],"output":{"name":"self"}}],[11,"build_from_row","","",71,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[11,"build","","",71,{"inputs":[{"name":"row"}],"output":{"name":"self"}}],[11,"build_from_row","","",71,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[11,"build","","",71,{"inputs":[{"name":"row"}],"output":{"name":"self"}}],[11,"as_expression","","",72,null],[11,"as_expression","","",72,null],[11,"to_sql","","",72,null],[11,"as_expression","","",73,null],[11,"as_expression","","",73,null],[11,"to_sql","","",73,null],[11,"as_expression","","",71,null],[11,"as_expression","","",71,null],[11,"to_sql","","",71,null],[11,"as_expression","","",71,null],[11,"as_expression","","",71,null],[11,"to_sql","","",71,null],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"has_static_query_id","diesel::types","",61,{"inputs":[],"output":{"name":"bool"}}],[11,"build_from_row","diesel::pg::types::date_and_time","",74,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[11,"build","","",74,{"inputs":[{"name":"row"}],"output":{"name":"self"}}],[11,"as_expression","","",74,null],[11,"as_expression","","",74,null],[11,"to_sql","","",74,null],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"to_sql","diesel::pg::types::date_and_time","",71,null],[11,"from_sql","","",71,{"inputs":[{"name":"option"}],"output":{"name":"result"}}],[11,"to_sql","","",71,null],[11,"from_sql","","",71,{"inputs":[{"name":"option"}],"output":{"name":"result"}}],[11,"to_sql","","",72,null],[11,"from_sql","","",72,{"inputs":[{"name":"option"}],"output":{"name":"result"}}],[11,"to_sql","","",73,null],[11,"from_sql","","",73,{"inputs":[{"name":"option"}],"output":{"name":"result"}}],[11,"to_sql","","",74,null],[11,"from_sql","","",74,{"inputs":[{"name":"option"}],"output":{"name":"result"}}],[11,"add","","",74,null],[0,"floats","diesel::pg::types","",null,null],[4,"PgNumeric","diesel::pg::types::floats","",null,null],[13,"Positive","","",75,null],[12,"weight","diesel::pg::types::floats::PgNumeric","",75,null],[12,"scale","","",75,null],[12,"digits","","",75,null],[13,"Negative","diesel::pg::types::floats","",75,null],[12,"weight","diesel::pg::types::floats::PgNumeric","",75,null],[12,"scale","","",75,null],[12,"digits","","",75,null],[13,"NaN","diesel::pg::types::floats","",75,null],[11,"arbitrary","","",75,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"fmt","","",75,null],[11,"clone","","",75,null],[11,"eq","","",75,null],[11,"ne","","",75,null],[11,"from_sql","","",75,{"inputs":[{"name":"option"}],"output":{"name":"result"}}],[11,"to_sql","","",75,null],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[11,"has_static_query_id","diesel::types","",60,{"inputs":[],"output":{"name":"bool"}}],[11,"build_from_row","diesel::pg::types::floats","",75,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[11,"build","","",75,{"inputs":[{"name":"row"}],"output":{"name":"self"}}],[11,"as_expression","","",75,null],[11,"as_expression","","",75,null],[11,"to_sql","","",75,null],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","diesel::backend","",5,{"inputs":[],"output":null}],[0,"sql_types","diesel::pg::types","PostgreSQL specific SQL types",null,null],[3,"Oid","diesel::pg::types::sql_types","The OID SQL type. This is a PostgreSQL specific type.",null,null],[3,"Timestamptz","","The &quot;timestamp with time zone&quot; SQL type, which PostgreSQL abbreviates\nto `timestamptz`.",null,null],[3,"Array","","The Array SQL type. This wraps another type to represent a SQL array of\nthat type. Multidimensional arrays are not supported, nor are arrays\ncontaining null.",null,null],[3,"Uuid","","The UUID SQL type. This type can only be used with `feature = &quot;uuid&quot;`",null,null],[6,"SmallSerial","","Alias for SmallInt",null,null],[6,"Serial","","Alias for Integer",null,null],[6,"BigSerial","","Alias for BigInt",null,null],[6,"Bytea","","Alias for `Binary`, to ensure `infer_schema!` works",null,null],[11,"fmt","","",76,null],[11,"clone","","",76,null],[11,"default","","",76,{"inputs":[],"output":{"name":"oid"}}],[11,"fmt","","",77,null],[11,"clone","","",77,null],[11,"default","","",77,{"inputs":[],"output":{"name":"timestamptz"}}],[11,"fmt","","",78,null],[11,"clone","","",78,null],[11,"default","","",78,{"inputs":[],"output":{"name":"array"}}],[11,"fmt","","",79,null],[11,"clone","","",79,null],[11,"default","","",79,{"inputs":[],"output":{"name":"uuid"}}],[0,"data_types","diesel::pg","",null,null],[3,"PgTimestamp","diesel::pg::data_types","Timestamps are represented in Postgres as a 64 bit signed integer representing the number of\nmicroseconds since January 1st 2000. This struct is a dumb wrapper type, meant only to indicate\nthe integer&#39;s meaning.",null,null],[12,"0","","",71,null],[3,"PgDate","","Dates are represented in Postgres as a 32 bit signed integer representing the number of julian\ndays since January 1st 2000. This struct is a dumb wrapper type, meant only to indicate the\ninteger&#39;s meaning.",null,null],[12,"0","","",72,null],[3,"PgTime","","Time is represented in Postgres as a 64 bit signed integer representing the number of\nmicroseconds since midnight. This struct is a dumb wrapper type, meant only to indicate the\ninteger&#39;s meaning.",null,null],[12,"0","","",73,null],[3,"PgInterval","","Intervals in Postgres are separated into 3 parts. A 64 bit integer representing time in\nmicroseconds, a 32 bit integer representing number of minutes, and a 32 bit integer\nrepresenting number of months. This struct is a dumb wrapper type, meant only to indicate the\nmeaning of these parts.",null,null],[12,"microseconds","","",74,null],[12,"days","","",74,null],[12,"months","","",74,null],[4,"PgNumeric","","",null,null],[13,"Positive","","",75,null],[12,"weight","diesel::pg::data_types::PgNumeric","",75,null],[12,"scale","","",75,null],[12,"digits","","",75,null],[13,"Negative","diesel::pg::data_types","",75,null],[12,"weight","diesel::pg::data_types::PgNumeric","",75,null],[12,"scale","","",75,null],[12,"digits","","",75,null],[13,"NaN","diesel::pg::data_types","",75,null],[0,"sqlite","diesel","",null,null],[3,"Sqlite","diesel::sqlite","",null,null],[3,"SqliteConnection","","",null,null],[4,"SqliteType","","",null,null],[13,"Binary","","",80,null],[13,"Text","","",80,null],[13,"Float","","",80,null],[13,"Double","","",80,null],[13,"SmallInt","","",80,null],[13,"Integer","","",80,null],[13,"Long","","",80,null],[11,"fmt","","",81,null],[11,"clone","","",81,null],[11,"batch_execute","","",82,null],[11,"establish","","",82,{"inputs":[{"name":"str"}],"output":{"name":"connectionresult"}}],[11,"metadata","","",81,{"inputs":[],"output":{"name":"sqlitetype"}}],[11,"metadata","","",81,{"inputs":[],"output":{"name":"sqlitetype"}}],[11,"metadata","","",81,{"inputs":[],"output":{"name":"sqlitetype"}}],[0,"query_builder","","",null,null],[3,"SqliteQueryBuilder","diesel::sqlite::query_builder","",null,null],[12,"sql","","",83,null],[0,"functions","","",null,null],[5,"insert_or_replace","diesel::sqlite::query_builder::functions","Creates a SQLite `INSERT OR REPLACE` statement. If a constraint violation\nfails, SQLite will attempt to replace the offending row instead.",null,{"inputs":[{"name":"t"}],"output":{"name":"incompleteinsertstatement"}}],[11,"new","diesel::sqlite::query_builder","",83,{"inputs":[],"output":{"name":"self"}}],[11,"push_sql","","",83,null],[11,"push_identifier","","",83,null],[11,"push_bind_param","","",83,null],[0,"migrations","diesel","Provides functions for maintaining database schema.",null,null],[4,"MigrationError","diesel::migrations","",null,null],[13,"MigrationDirectoryNotFound","","",84,null],[13,"UnknownMigrationFormat","","",84,null],[13,"IoError","","",84,null],[13,"UnknownMigrationVersion","","",84,null],[4,"RunMigrationsError","","",null,null],[13,"MigrationError","","",85,null],[13,"QueryError","","",85,null],[5,"migration_from","","",null,{"inputs":[{"name":"pathbuf"}],"output":{"name":"result"}}],[5,"run_pending_migrations","","Runs all migrations that have not yet been run. This function will print all progress to\nstdout. This function will return an `Err` if some error occurs reading the migrations, or if\nany migration fails to run. Each migration is run in its own transaction, so some migrations\nmay be committed, even if a later migration fails to run.",null,{"inputs":[{"name":"conn"}],"output":{"name":"result"}}],[5,"revert_latest_migration","","Reverts the last migration that was run. Returns the version that was reverted. Returns an\n`Err` if no migrations have ever been run.",null,{"inputs":[{"name":"conn"}],"output":{"name":"result"}}],[5,"run_migrations","","Run all pending migrations in the given list. Apps should likely be calling\n`run_pending_migrations` or `run_pending_migrations_in_directory` instead.",null,{"inputs":[{"name":"conn"},{"name":"list"},{"name":"write"}],"output":{"name":"result"}}],[5,"find_migrations_directory","","Returns the directory containing migrations. Will look at for\n$PWD/migrations. If it is not found, it will search the parents of the\ncurrent directory, until it reaches the root directory.  Returns\n`MigrationError::MigrationDirectoryNotFound` if no directory is found.",null,{"inputs":[],"output":{"name":"result"}}],[5,"search_for_migrations_directory","","Searches for the migrations directory relative to the given path. See\n`find_migrations_directory` for more details.",null,{"inputs":[{"name":"path"}],"output":{"name":"result"}}],[11,"fmt","","",84,null],[11,"description","","",84,null],[11,"fmt","","",84,null],[11,"eq","","",84,null],[11,"from","","",84,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"fmt","","",85,null],[11,"eq","","",85,null],[11,"ne","","",85,null],[11,"description","","",85,null],[11,"fmt","","",85,null],[11,"from","","",85,{"inputs":[{"name":"migrationerror"}],"output":{"name":"self"}}],[11,"from","","",85,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",85,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",85,{"inputs":[{"name":"transactionerror"}],"output":{"name":"self"}}],[8,"MigrationConnection","","A connection which can be passed to the migration methods. This exists only\nto wrap up some constraints which are meant to hold for *all* connections.\nThis trait will go away at some point in the future. Any Diesel connection\nshould be useable where this trait is required.",null,null],[10,"previously_run_migration_versions","","",86,null],[10,"latest_run_migration_version","","",86,null],[10,"insert_new_migration","","",86,null],[8,"Migration","","",null,null],[10,"version","","",87,null],[10,"run","","",87,null],[10,"revert","","",87,null],[0,"query_source","diesel","Types in this module are mostly internal and automatically generated. You\nshouldn&#39;t need to interact with these types during normal usage, other than\nthe methods on [`Table`](trait.Table.html)",null,null],[8,"JoinTo","diesel::query_source","Indicates that two tables can be used together in a JOIN clause.\nImplementations of this trait will be generated for you automatically by\nthe [association annotations](FIXME: Add link) from codegen.",null,null],[8,"Queryable","","Trait indicating that a record can be queried from the database. This trait\ncan be derived automatically using `diesel_codegen`. This trait can only be derived for\nstructs, not enums.",null,null],[16,"Row","","",88,null],[10,"build","","",88,{"inputs":[{"name":"row"}],"output":{"name":"self"}}],[8,"Column","","A column on a database table. Types which implement this trait should have\nbeen generated by the [`table!` macro](../macro.table!.html).",null,null],[16,"Table","","",89,null],[10,"name","","",89,{"inputs":[],"output":{"name":"str"}}],[8,"Table","","A SQL database table. Types which implement this trait should have been\ngenerated by the [`table!` macro](../macro.table!.html).",null,null],[16,"PrimaryKey","","",90,null],[16,"AllColumns","","",90,null],[10,"name","","",90,{"inputs":[],"output":{"name":"str"}}],[10,"primary_key","","",90,null],[10,"all_columns","","",90,{"inputs":[],"output":{"name":"allcolumns"}}],[11,"inner_join","","",90,null],[11,"left_outer_join","","",90,null],[0,"result","diesel","",null,null],[4,"Error","diesel::result","The generic &quot;things can fail in a myriad of ways&quot; enum. This type is not\nindended to be exhaustively matched, and new variants may be added in the\nfuture without a major version bump.",null,null],[13,"InvalidCString","","",91,null],[13,"DatabaseError","","",91,null],[13,"NotFound","","",91,null],[13,"QueryBuilderError","","",91,null],[13,"DeserializationError","","",91,null],[13,"SerializationError","","",91,null],[4,"DatabaseErrorKind","","The kind of database error that occurred. This is not meant to exhaustively\ncover all possible errors, but is used to identify errors which are commonly\nrecovered from programatically. This enum is not intended to be exhaustively\nmatched, and new variants may be added in the future without a major version\nbump.",null,null],[13,"UniqueViolation","","",92,null],[4,"ConnectionError","","",null,null],[13,"InvalidCString","","",93,null],[13,"BadConnection","","",93,null],[4,"TransactionError","","",null,null],[13,"CouldntCreateTransaction","","",94,null],[13,"UserReturnedError","","",94,null],[6,"QueryResult","","",null,null],[6,"ConnectionResult","","",null,null],[6,"TransactionResult","","",null,null],[8,"DatabaseErrorInformation","","",null,null],[10,"message","","",95,null],[10,"details","","",95,null],[10,"hint","","",95,null],[10,"table_name","","",95,null],[10,"column_name","","",95,null],[10,"constraint_name","","",95,null],[8,"OptionalExtension","","",null,null],[10,"optional","","",96,null],[11,"fmt","","",91,null],[11,"fmt","","",92,null],[11,"clone","","",92,null],[11,"fmt","","",95,null],[11,"fmt","","",93,null],[11,"fmt","","",94,null],[11,"eq","","",94,null],[11,"ne","","",94,null],[11,"optional","","",97,null],[11,"from","","",93,{"inputs":[{"name":"nulerror"}],"output":{"name":"self"}}],[11,"from","","",91,{"inputs":[{"name":"nulerror"}],"output":{"name":"self"}}],[11,"from","","",94,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",91,{"inputs":[{"name":"transactionerror"}],"output":{"name":"self"}}],[11,"fmt","","",91,null],[11,"description","","",91,null],[11,"fmt","","",93,null],[11,"description","","",93,null],[11,"fmt","","",94,null],[11,"description","","",94,null],[11,"eq","","",91,null],[0,"helper_types","diesel","Provide helper types for concisely writing the return type of functions.\nAs with iterators, it is unfortunately difficult to return a partially\nconstructed query without exposing the exact implementation of the\nfunction. Without higher kinded types, these various DSLs can&#39;t be\ncombined into a single trait for boxing purposes.",null,null],[6,"Select","diesel::helper_types","Represents the return type of `.select(selection)`",null,null],[6,"Filter","","Represents the return type of `.filter(predicate)`",null,null],[6,"FindBy","","Represents the return type of `.filter(lhs.eq(rhs))`",null,null],[6,"Find","","Represents the return type of `.find(pk)`",null,null],[6,"Order","","Represents the return type of `.order(ordering)`",null,null],[6,"Limit","","Represents the return type of `.limit()`",null,null],[6,"Offset","","Represents the return type of `.offset()`",null,null],[6,"With","","Represents the return type of `.with(aliased_expr)`",null,null],[6,"Update","","Represents the return type of `update(lhs).set(rhs)`",null,null],[0,"prelude","diesel","Re-exports important traits and types. Meant to be glob imported when using Diesel.",null,null],[8,"GroupedBy","diesel::prelude","",null,null],[10,"grouped_by","","",1,null],[8,"Insertable","","Represents that a structure can be used to to insert a new row into the\ndatabase. This is automatically implemented for `&amp;[T]` and `&amp;Vec&lt;T&gt;` for\ninserting more than one record.",null,null],[16,"Values","","",98,null],[10,"values","","",98,null],[8,"BelongingToDsl","","",null,null],[16,"Output","","",99,null],[10,"belonging_to","","",99,{"inputs":[{"name":"t"}],"output":{"name":"output"}}],[8,"BoxedDsl","","Boxes the pieces of a query into a single type. This is useful for cases\nwhere you want to conditionally modify a query, but need the type to remain\nthe same. The backend must be specified as part of this. It is not possible\nto box a query and have it be useable on multiple backends.",null,null],[11,"into_boxed","","",100,null],[8,"CountDsl","","Adds a simple `count` function to queries. Automatically implemented for all\ntypes which implement `SelectDsl`.",null,null],[11,"count","","Get the count of a query. This is equivalent to `.select(count_star())`",101,null],[8,"DistinctDsl","","Adds the `DISTINCT` keyword to a query.",null,null],[16,"Output","","",102,null],[10,"distinct","","",102,null],[8,"FilterDsl","","Adds to the `WHERE` clause of a query. If there is already a `WHERE` clause,\nthe result will be `old AND new`. This is automatically implemented for the\nvarious query builder types.",null,null],[16,"Output","","",103,null],[10,"filter","","",103,null],[8,"FindDsl","","Attempts to find a single record from the given table by primary key.",null,null],[16,"Output","","",104,null],[10,"find","","",104,null],[8,"LimitDsl","","Sets the limit clause of a query. If there was already a limit clause, it\nwill be overridden. This is automatically implemented for the various query\nbuilder types.",null,null],[16,"Output","","",105,null],[10,"limit","","",105,null],[8,"LoadDsl","","Methods to execute a query given a connection. These are automatically implemented for the\nvarious query types.",null,null],[10,"load","","Executes the given query, returning an `Iterator` over the returned\nrows.",106,null],[11,"first","","Attempts to load a single record. Returns `Ok(record)` if found, and\n`Err(NotFound)` if no results are returned. If the query truly is\noptional, you can call `.optional()` on the result of this to get a\n`Result&lt;Option&lt;U&gt;&gt;`.",106,null],[10,"get_result","","Runs the command, and returns the affected row. `Err(NotFound)` will be\nreturned if the query affected 0 rows. You can call `.optional()` on the\nresult of this if the command was optional to get back a\n`Result&lt;Option&lt;U&gt;&gt;`",106,null],[11,"get_results","","Runs the command, returning an `Iterator` over the affected rows.",106,null],[8,"ExecuteDsl","","",null,null],[11,"execute","","Executes the given command, returning the number of rows affected. Used\nin conjunction with\n[`update`](../query_builder/fn.update.html) and\n[`delete`](../query_builder/fn.delete.html)",107,null],[8,"OffsetDsl","","Sets the offset clause of a query. If there was already a offset clause, it\nwill be overridden. This is automatically implemented for the various query\nbuilder types.",null,null],[16,"Output","","",108,null],[10,"offset","","",108,null],[8,"OrderDsl","","Sets the order clause of a query. If there was already a order clause, it\nwill be overridden. The expression passed to `order` must actually be valid\nfor the query. See also:\n[`.desc()`](expression/expression_methods/global_expression_methods/trait.ExpressionMethods.html#method.desc)\nand [`.asc()`](expression/expression_methods/global_expression_methods/trait.ExpressionMethods.html#method.asc)",null,null],[16,"Output","","",109,null],[10,"order","","",109,null],[8,"SaveChangesDsl","","",null,null],[10,"save_changes","","",110,null],[8,"SelectDsl","","Sets the select clause of a query. If there was already a select clause, it\nwill be overridden. The expression passed to `select` must actually be valid\nfor the query (only contains columns from the target table, doesn&#39;t mix\naggregate + non-aggregate expressions, etc).",null,null],[16,"Output","","",111,null],[10,"select","","",111,null],[8,"WithDsl","","Adds an additional expression to the FROM clause. This is useful for things\nlike full text search, where you need to access the result of an expensive\ncomputation for the where clause that shouldn&#39;t be redone for each row, such\nas `plain_to_tsquery`. See\n[`.aliased`](expression/expression_methods/global_expression_methods/trait.ExpressionMethods.html#method.aliased)\nfor more",null,null],[16,"Output","","",112,null],[10,"with","","",112,null],[8,"JoinTo","","Indicates that two tables can be used together in a JOIN clause.\nImplementations of this trait will be generated for you automatically by\nthe [association annotations](FIXME: Add link) from codegen.",null,null],[0,"data_types","diesel","Structs to represent the primitive equivalent of SQL types where\nthere is no existing Rust primitive, or where using it would be\nconfusing (such as date and time types). This module will re-export\nall backend specific data structures when compiled against that\nbackend.",null,null],[14,"table","","Specifies that a table exists, and what columns it has. This will create a\nnew public module, with the same name, as the name of the table. In this\nmodule, you&#39;ll find a unit struct named `table`, and a unit struct with the\nnames of each of the columns. In the definition, you can also specify an\nadditional set of columns which exist, but should not be selected by default\n(for example, for things like full text search)",null,null],[14,"debug_sql","","Takes a query QueryFragment expression as an argument and returns a string\nof SQL with placeholders for the dynamic values.",null,null],[14,"print_sql","","Takes takes a query QueryFragment expression as an argument and prints out\nthe SQL with placeholders for the dynamic values.",null,null],[14,"impl_query_id","","",null,null],[14,"infer_schema","","Queries the database for the names of all tables, and calls\n[`infer_table_from_schema!`](macro.infer_table_from_schema!.html) for each\none.",null,null],[14,"infer_table_from_schema","","Establishes a database connection at compile time, loads the schema information about a table&#39;s\ncolumns, and invokes [`table!`](macro.table!.html) for you automatically.",null,null],[14,"embed_migrations","","This macro will read your migrations at compile time, and embed a module you can use to execute\nthem at runtime without the migration files being present on the file system. This is useful if\nyou would like to use Diesel&#39;s migration infrastructure, but want to ship a single executable\nfile (such as for embedded applications). It can also be used to apply migrations to an in\nmemory database (Diesel does this for its own test suite).",null,null],[14,"AsChangeset","","Implements the [`AsChangeset`][changeset] trait for a given struct. This\nmacro should be called with the name of the table you wish to use the struct\nwith, followed by the entire struct body. This macro mirrors\n`#[as_changeset]` from [`diesel_codegen`][diesel_codegen]",null,null],[14,"BelongsTo","","Defines a one-to-one association for the child table. This macro should be\ncalled with the name of the parent struct, followed by any options, followed\nby the entire struct body. The struct *must* be annotated with\n`#[table_name(name_of_table)]`. Both the parent and child structs must\nimplement [`Identifiable`][identifiable].",null,null],[14,"HasMany","","Defines a one-to-many association for the parent table. This macro is only required if you need\nto join between the two tables. This macro should be called with the name of the child table,\nfollowed by any options, followed by the entire struct body. The struct *must* be annotated with\n`#[table_name(name_of_table)]`. Both the parent and child structs must implement\n[`Identifiable`][identifiable].",null,null],[14,"Identifiable","","Implements the [`Identifiable`][identifiable] trait for a given struct. This\nmacro should be called by copy/pasting the definition of the struct into it.",null,null],[14,"Insertable","","Implements the [`Insertable`][insertable] trait for a given struct. This\nmacro should be called with the name of the table you wish to use the struct\nwith, followed by the entire struct body.",null,null],[14,"Queryable","","Implements the [`Queryable`][queryable] trait for a given struct. This macro\nshould be called by copy/pasting the definition of the struct into it.",null,null],[14,"operator_allowed","","Implements the Rust operator for a given type. If you create a new SQL\nfunction, which returns a type that you&#39;d like to use an operator on, you\nshould invoke this macro. Unfortunately, Rust disallows us from\nautomatically implementing `Add` and other traits from `std::ops`, under its\norphan rules.",null,null],[14,"numeric_expr","","Indicates that an expression allows all numeric operators. If you create new\nSQL functions that return a numeric type, you should invoke this macro that\ntype. Unfortunately, Rust disallows us from automatically implementing `Add`\nfor types which implement `Expression`, under its orphan rules.",null,null],[14,"sql_function","","Declare a sql function for use in your code. Useful if you have your own SQL functions that\nyou&#39;d like to use. You can optionally provide a doc string as well. `$struct_name` should just\nbe any unique name. You will not need to reference it in your code, but it is required due to\nthe fact that [`concat_idents!` is\nuseless](https://github.com/rust-lang/rust/issues/29599#issuecomment-153927167).",null,null],[14,"no_arg_sql_function","","Declare a 0 argument SQL function for use in your code. This will generate a\nunit struct, which is an expression representing calling this function. See\n[`now`](expression/dsl/struct.now.html) for example output. `now` was\ngenerated using:",null,null],[14,"infix_predicate","","Useful for libraries adding support for new SQL types. Apps should never\nneed to call this",null,null],[14,"postfix_predicate","","Useful for libraries adding support for new SQL types. Apps should never\nneed to call this.",null,null],[14,"postfix_expression","","",null,null],[11,"fmt","diesel::expression::dsl","",113,null],[11,"clone","","",113,null],[11,"to_sql","","",113,null],[11,"collect_binds","","",113,null],[11,"is_safe_to_cache_prepared","","",113,null],[11,"has_static_query_id","","",113,{"inputs":[],"output":{"name":"bool"}}],[11,"fmt","","",114,null],[11,"clone","","",114,null],[11,"to_sql","","",114,null],[11,"collect_binds","","",114,null],[11,"is_safe_to_cache_prepared","","",114,null],[11,"has_static_query_id","","",114,{"inputs":[],"output":{"name":"bool"}}],[11,"fmt","","",115,null],[11,"clone","","",115,null],[11,"to_sql","","",115,null],[11,"collect_binds","","",115,null],[11,"is_safe_to_cache_prepared","","",115,null],[11,"has_static_query_id","","",115,{"inputs":[],"output":{"name":"bool"}}],[11,"fmt","","",116,null],[11,"clone","","",116,null],[11,"to_sql","","",116,null],[11,"collect_binds","","",116,null],[11,"is_safe_to_cache_prepared","","",116,null],[11,"has_static_query_id","","",116,{"inputs":[],"output":{"name":"bool"}}],[11,"fmt","","",117,null],[11,"clone","","",117,null],[11,"to_sql","","",117,null],[11,"collect_binds","","",117,null],[11,"is_safe_to_cache_prepared","","",117,null],[11,"has_static_query_id","","",117,{"inputs":[],"output":{"name":"bool"}}],[11,"add","","",117,null],[11,"sub","","",117,null],[11,"query_id","diesel::query_builder","",32,{"inputs":[],"output":{"name":"option"}}],[11,"has_static_query_id","","",35,{"inputs":[],"output":{"name":"bool"}}],[11,"metadata","diesel::sqlite","",81,{"inputs":[],"output":{"name":"sqlitetype"}}],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","diesel::sqlite","",81,{"inputs":[],"output":{"name":"sqlitetype"}}],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","diesel::sqlite","",81,{"inputs":[],"output":{"name":"sqlitetype"}}],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","diesel::sqlite","",81,{"inputs":[],"output":{"name":"sqlitetype"}}],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","diesel::sqlite","",81,{"inputs":[],"output":{"name":"sqlitetype"}}],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","diesel::sqlite","",81,{"inputs":[],"output":{"name":"sqlitetype"}}],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","diesel::sqlite","",81,{"inputs":[],"output":{"name":"sqlitetype"}}],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"metadata","diesel::sqlite","",81,{"inputs":[],"output":{"name":"sqlitetype"}}],[11,"metadata","diesel::pg","",69,{"inputs":[],"output":{"name":"pgtypemetadata"}}],[11,"milliseconds","diesel::pg::expression::extensions","Returns a PgInterval representing `self` as milliseconds",67,null],[11,"seconds","","Returns a PgInterval representing `self` as seconds",67,null],[11,"minutes","","Returns a PgInterval representing `self` as minutes",67,null],[11,"hours","","Returns a PgInterval representing `self` as hours",67,null],[11,"microsecond","","Identical to `microseconds`",67,null],[11,"millisecond","","Identical to `milliseconds`",67,null],[11,"second","","Identical to `seconds`",67,null],[11,"minute","","Identical to `minutes`",67,null],[11,"hour","","Identical to `hours`",67,null],[11,"weeks","","Returns a PgInterval representing `self` in weeks",68,null],[11,"years","","Returns a PgInterval representing `self` in weeks",68,null],[11,"day","","Identical to `days`",68,null],[11,"week","","Identical to `weeks`",68,null],[11,"month","","Identical to `months`",68,null],[11,"year","","Identical to `years`",68,null],[11,"has_static_query_id","diesel::pg::types::sql_types","",78,{"inputs":[],"output":{"name":"bool"}}],[11,"has_static_query_id","","",77,{"inputs":[],"output":{"name":"bool"}}],[11,"has_static_query_id","","",76,{"inputs":[],"output":{"name":"bool"}}],[11,"has_static_query_id","","",79,{"inputs":[],"output":{"name":"bool"}}],[11,"into_boxed","diesel::prelude","",100,null],[11,"count","","Get the count of a query. This is equivalent to `.select(count_star())`",101,null],[11,"first","","Attempts to load a single record. Returns `Ok(record)` if found, and\n`Err(NotFound)` if no results are returned. If the query truly is\noptional, you can call `.optional()` on the result of this to get a\n`Result&lt;Option&lt;U&gt;&gt;`.",106,null],[11,"get_results","","Runs the command, returning an `Iterator` over the affected rows.",106,null],[11,"execute","","Executes the given command, returning the number of rows affected. Used\nin conjunction with\n[`update`](../query_builder/fn.update.html) and\n[`delete`](../query_builder/fn.delete.html)",107,null],[11,"into_boxed","","",100,null],[11,"count","","Get the count of a query. This is equivalent to `.select(count_star())`",101,null],[11,"first","","Attempts to load a single record. Returns `Ok(record)` if found, and\n`Err(NotFound)` if no results are returned. If the query truly is\noptional, you can call `.optional()` on the result of this to get a\n`Result&lt;Option&lt;U&gt;&gt;`.",106,null],[11,"get_results","","Runs the command, returning an `Iterator` over the affected rows.",106,null],[11,"execute","","Executes the given command, returning the number of rows affected. Used\nin conjunction with\n[`update`](../query_builder/fn.update.html) and\n[`delete`](../query_builder/fn.delete.html)",107,null],[11,"into_boxed","","",100,null],[11,"count","","Get the count of a query. This is equivalent to `.select(count_star())`",101,null],[11,"first","","Attempts to load a single record. Returns `Ok(record)` if found, and\n`Err(NotFound)` if no results are returned. If the query truly is\noptional, you can call `.optional()` on the result of this to get a\n`Result&lt;Option&lt;U&gt;&gt;`.",106,null],[11,"get_results","","Runs the command, returning an `Iterator` over the affected rows.",106,null],[11,"execute","","Executes the given command, returning the number of rows affected. Used\nin conjunction with\n[`update`](../query_builder/fn.update.html) and\n[`delete`](../query_builder/fn.delete.html)",107,null]],"paths":[[8,"BelongsTo"],[8,"GroupedBy"],[8,"Identifiable"],[8,"Backend"],[8,"TypeMetadata"],[3,"Debug"],[8,"Connection"],[8,"BoolExpressionMethods"],[8,"EscapeExpressionMethods"],[8,"ExpressionMethods"],[8,"TextExpressionMethods"],[3,"IsNull"],[3,"IsNotNull"],[3,"Asc"],[3,"Desc"],[3,"SqlLiteral"],[8,"Expression"],[8,"AsExpression"],[8,"BoxableExpression"],[3,"RawBytesBindCollector"],[8,"BindCollector"],[8,"WhereAnd"],[3,"NoWhereClause"],[3,"WhereClause"],[3,"IncompleteInsertStatement"],[3,"InsertStatement"],[3,"Insert"],[8,"AsChangeset"],[8,"Changeset"],[8,"IntoUpdateTarget"],[3,"IncompleteUpdateStatement"],[3,"UpdateStatement"],[8,"QueryId"],[8,"QueryBuilder"],[8,"Query"],[8,"QueryFragment"],[8,"AsQuery"],[4,"IsNull"],[8,"Add"],[8,"Sub"],[8,"Mul"],[8,"Div"],[3,"Nullable"],[3,"Bool"],[3,"SmallInt"],[3,"Integer"],[3,"BigInt"],[3,"Float"],[3,"Double"],[3,"Text"],[3,"Binary"],[3,"Date"],[3,"Time"],[3,"Timestamp"],[8,"Foldable"],[8,"HasSqlType"],[8,"IntoNullable"],[8,"FromSql"],[8,"FromSqlRow"],[8,"ToSql"],[3,"Numeric"],[3,"Interval"],[3,"PgTypeMetadata"],[3,"PgQueryBuilder"],[8,"PgExpressionMethods"],[8,"ArrayExpressionMethods"],[8,"SortExpressionMethods"],[8,"MicroIntervalDsl"],[8,"DayAndMonthIntervalDsl"],[3,"Pg"],[3,"PgConnection"],[3,"PgTimestamp"],[3,"PgDate"],[3,"PgTime"],[3,"PgInterval"],[4,"PgNumeric"],[3,"Oid"],[3,"Timestamptz"],[3,"Array"],[3,"Uuid"],[4,"SqliteType"],[3,"Sqlite"],[3,"SqliteConnection"],[3,"SqliteQueryBuilder"],[4,"MigrationError"],[4,"RunMigrationsError"],[8,"MigrationConnection"],[8,"Migration"],[8,"Queryable"],[8,"Column"],[8,"Table"],[4,"Error"],[4,"DatabaseErrorKind"],[4,"ConnectionError"],[4,"TransactionError"],[8,"DatabaseErrorInformation"],[8,"OptionalExtension"],[6,"QueryResult"],[8,"Insertable"],[8,"BelongingToDsl"],[8,"BoxedDsl"],[8,"CountDsl"],[8,"DistinctDsl"],[8,"FilterDsl"],[8,"FindDsl"],[8,"LimitDsl"],[8,"LoadDsl"],[8,"ExecuteDsl"],[8,"OffsetDsl"],[8,"OrderDsl"],[8,"SaveChangesDsl"],[8,"SelectDsl"],[8,"WithDsl"],[3,"Max"],[3,"Min"],[3,"Sum"],[3,"Avg"],[3,"now"]]};
initSearch(searchIndex);
